CREATE TABLE IMAGES_DATASET(
	ID SERIAL, 
	NAME VARCHAR, 
	COLOR_HISTOGRAM_VECTOR REAL[], 
	PRIMARY KEY (ID)
);

CREATE TABLE PIVOTS(
	ID SERIAL,
	IMAGE_ID INT,
	PRIMARY KEY (ID),
	FOREIGN KEY (IMAGE_ID) REFERENCES IMAGES_DATASET(ID)
);
	
CREATE TABLE NODES(
	ID SERIAL, 
	PARENT_ID INT NULL,
	DISTANCE REAL, 
	PIVOT_ID INT NULL,
	PRIMARY KEY (ID),
	FOREIGN KEY (PARENT_ID) REFERENCES NODES(ID),
	FOREIGN KEY (PIVOT_ID) REFERENCES PIVOTS(ID)
);
	
CREATE TABLE IMAGES(
	ID SERIAL, 
	IMAGE_ID INT,
	NODE_ID INT, 
	PRIMARY KEY (ID),
	FOREIGN KEY (IMAGE_ID) REFERENCES IMAGES_DATASET(ID),
	FOREIGN KEY (NODE_ID) REFERENCES NODES(ID)
);

CREATE OR REPLACE FUNCTION HISTOGRAM_EUCLIDEAN_DISTANCE(HISTOGRAM_1 real[], HISTOGRAM_2 real[]) 
RETURNS REAL 
AS $$
DECLARE
  DISTANCE REAL;
BEGIN
  DISTANCE := 0;
  FOR I IN 1..ARRAY_LENGTH(HISTOGRAM_1, 1) LOOP
    DISTANCE := DISTANCE + POWER((HISTOGRAM_1[I] - HISTOGRAM_2[I]), 2);
  END LOOP;
  RETURN SQRT(DISTANCE);
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION PIVOT_CANDIDATE_MU(PIVOTS INT[], PIVOT_CANDIDATE INT, PAIRS_OBJECT INT[]) 
RETURNS FLOAT
AS $$
DECLARE
	PIVOT_ID INT;
	PIVOT INT[];
	I INT;
	PAIRS_OBJECT_A_ELEM INT[];
	PAIRS_OBJECT_B_ELEM INT[];
	MAX_DIFFERENCE FLOAT;
	DIFFERENCE FLOAT;
	TOTAL_DIFFERENCE FLOAT;
BEGIN
	PIVOTS := ARRAY_APPEND(PIVOTS, PIVOT_CANDIDATE);
	TOTAL_DIFFERENCE := 0.0;
	I := 1;
	WHILE (I < CARDINALITY(PAIRS_OBJECT)) LOOP
		PAIRS_OBJECT_A_ELEM := (SELECT COLOR_HISTOGRAM_VECTOR FROM IMAGES_DATASET WHERE ID = PAIRS_OBJECT[I] LIMIT 1);
		PAIRS_OBJECT_B_ELEM := (SELECT COLOR_HISTOGRAM_VECTOR FROM IMAGES_DATASET WHERE ID = PAIRS_OBJECT[I+1] LIMIT 1);
		MAX_DIFFERENCE := 0.0;
		FOREACH PIVOT_ID IN ARRAY PIVOTS LOOP
			PIVOT := (SELECT COLOR_HISTOGRAM_VECTOR FROM IMAGES_DATASET WHERE ID = PIVOT_ID LIMIT 1);
			DIFFERENCE := ABS(HISTOGRAM_EUCLIDEAN_DISTANCE(PAIRS_OBJECT_A_ELEM, PIVOT) -
							 HISTOGRAM_EUCLIDEAN_DISTANCE(PAIRS_OBJECT_B_ELEM, PIVOT))::FLOAT;
			IF DIFFERENCE > MAX_DIFFERENCE THEN
				MAX_DIFFERENCE := DIFFERENCE;
			END IF;
		END LOOP;
		TOTAL_DIFFERENCE := TOTAL_DIFFERENCE + MAX_DIFFERENCE;
		I := I + 2;
	END LOOP;
	RETURN TOTAL_DIFFERENCE/(CARDINALITY(PAIRS_OBJECT)::FLOAT/2.0);
END; 
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION INCREMENTAL_PIVOT_SELECTION(N_PIVOTS INT, K_SAMPLE INT, PAIRS_OBJECT INT) 
RETURNS INT[]
AS $$
DECLARE
	PIVOTS INT[];
	SAMPLE INT[];
	PAIRS INT[];
	PIVOT_CANDIDATE INT;
	AVERAGE_MU FLOAT;
	MAX_MU_AVERAGE FLOAT;
	SELECTED_PIVOT INT;
BEGIN
	PIVOTS := ARRAY[]::INT[];
	WHILE (CARDINALITY(PIVOTS) < N_PIVOTS) LOOP
		SAMPLE := ARRAY(SELECT ID FROM IMAGES_DATASET WHERE ID != ALL(PIVOTS) ORDER BY RANDOM() LIMIT K_SAMPLE);
		PAIRS := ARRAY(SELECT ID FROM IMAGES_DATASET  WHERE ID != ALL(PIVOTS) AND ID != ALL(SAMPLE) ORDER BY RANDOM() LIMIT PAIRS_OBJECT*2);
		MAX_MU_AVERAGE := 0.0;
		SELECTED_PIVOT := SAMPLE[0];
		FOREACH PIVOT_CANDIDATE IN ARRAY SAMPLE LOOP
			AVERAGE_MU := PIVOT_CANDIDATE_MU(PIVOTS, PIVOT_CANDIDATE, PAIRS);
			IF AVERAGE_MU > MAX_MU_AVERAGE THEN
				MAX_MU_AVERAGE := AVERAGE_MU;
				SELECTED_PIVOT := PIVOT_CANDIDATE;
			END IF;
		END LOOP;
	PIVOTS := ARRAY_APPEND(PIVOTS, SELECTED_PIVOT);
	END LOOP;
	RETURN PIVOTS;
END; 
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION CREATE_PIVOTS(N_PIVOTS INT, K_SAMPLE INT, PAIRS_OBJECT INT) 
RETURNS VOID 
AS $$
DECLARE
  PIVOT_IDS INT[];
  PIVOT_ID INT;
  COLOR_HISTOGRAM INT[];
BEGIN
	PIVOT_IDS := ARRAY(select INCREMENTAL_PIVOT_SELECTION(N_PIVOTS, K_SAMPLE, PAIRS_OBJECT));
	FOREACH PIVOT_ID IN ARRAY PIVOT_IDS LOOP
		COLOR_HISTOGRAM := (SELECT COLOR_HISTOGRAM_VECTOR FROM IMAGES_DATASET WHERE ID = PIVOT_ID LIMIT 1);
		INSERT INTO PIVOTS(COLOR_HISTOGRAM_VECTOR) VALUES (COLOR_HISTOGRAM);
	END LOOP;
END;
$$ LANGUAGE PLPGSQL;

CREATE OR REPLACE FUNCTION ADD_IMAGE() 
RETURNS TRIGGER 
AS $$
DECLARE
	DISTANCE_PIVOT_IMAGE INT;
	PIVOT_OBJECT RECORD;
	ROOT_NODE_ID INT;
	X_NODE_ID INT;
	PIVOT_COLOR_HISTOGRAM_VECTOR INT[];
	IMAGE_COLOR_HISTOGRAM_VECTOR INT[];
BEGIN
	ROOT_NODE_ID := 1;
	FOR PIVOT_OBJECT IN SELECT * FROM PIVOTS
		LOOP
			PIVOT_COLOR_HISTOGRAM_VECTOR := (
				SELECT COLOR_HISTOGRAM_VECTOR
				FROM IMAGES_DATASET
				WHERE ID = PIVOT_OBJECT.IMAGE_ID
				LIMIT 1
			);
			
			IMAGE_COLOR_HISTOGRAM_VECTOR := (
				SELECT COLOR_HISTOGRAM_VECTOR
				FROM IMAGES_DATASET
				WHERE ID = NEW.IMAGE_ID
				LIMIT 1
			);
			
			DISTANCE_PIVOT_IMAGE := HISTOGRAM_EUCLIDEAN_DISTANCE(PIVOT_COLOR_HISTOGRAM_VECTOR, IMAGE_COLOR_HISTOGRAM_VECTOR);

			X_NODE_ID := (
				SELECT ID
				FROM NODES
				WHERE PARENT_ID = ROOT_NODE_ID AND DISTANCE = DISTANCE_PIVOT_IMAGE
				LIMIT 1
			);

			IF (X_NODE_ID IS NULL) THEN
				INSERT INTO NODES(PARENT_ID, DISTANCE, PIVOT_ID) VALUES (
					ROOT_NODE_ID,
					DISTANCE_PIVOT_IMAGE,
					PIVOT_OBJECT.ID
				);

				ROOT_NODE_ID := (
					SELECT ID
					FROM NODES
					WHERE PARENT_ID = ROOT_NODE_ID AND DISTANCE = DISTANCE_PIVOT_IMAGE
					LIMIT 1
				);
			ELSE
				ROOT_NODE_ID := X_NODE_ID;
			END IF;
		END LOOP;

	NEW.NODE_ID := ROOT_NODE_ID;

	RETURN NEW;
END;
$$ 
LANGUAGE PLPGSQL;


CREATE TRIGGER ADD_IMAGE
BEFORE
INSERT ON IMAGES
FOR EACH ROW EXECUTE PROCEDURE ADD_IMAGE();

-- MIGRATE IMAGES_DATASET TO IMAGES
DO $$
DECLARE
  IMAGE_ID INT;
BEGIN
	-- PARENT NODE
	INSERT INTO NODES(ID, PARENT_ID, DISTANCE, PIVOT_ID) VALUES (1, NULL, 0, NULL); 
	FOR IMAGE_ID IN SELECT ID FROM IMAGES_DATASET LOOP
		INSERT INTO IMAGES(IMAGE_ID) VALUES (IMAGE_ID);
	END LOOP;
END;


CREATE OR REPLACE FUNCTION 	IMAGES_SIMILARITY_SEARCH(IMAGE_COLOR_HISTOGRAM_VECTOR REAL[], RADIUS int) 
RETURNS TABLE (
	IMAGE_NAME VARCHAR, 
	IMAGE_DISTANCE REAL
) AS $$
DECLARE
	PARENT_IDS INT[];
	PIVOT_DISTANCE REAL;
	PIVOT_COLOR_HISTOGRAM_VECTOR REAL[];
BEGIN
	PARENT_IDS := ARRAY(
		SELECT ID 
		FROM NODES 
		WHERE PARENT_ID IS NULL
	);
	
	FOR PIVOT_COLOR_HISTOGRAM_VECTOR IN (SELECT IMAGES_DATASET.COLOR_HISTOGRAM_VECTOR FROM PIVOTS, IMAGES_DATASET WHERE PIVOTS.IMAGE_ID = IMAGES_DATASET.ID)
	LOOP
		PIVOT_DISTANCE := HISTOGRAM_EUCLIDEAN_DISTANCE(PIVOT_COLOR_HISTOGRAM_VECTOR, IMAGE_COLOR_HISTOGRAM_VECTOR);
		PARENT_IDS := ARRAY(
			SELECT ID 
			FROM NODES 
			WHERE (DISTANCE BETWEEN PIVOT_DISTANCE - RADIUS AND PIVOT_DISTANCE + RADIUS) 
			AND PARENT_ID = ANY(PARENT_IDS)
		);
	END LOOP;
	
	RETURN QUERY 
		SELECT IMAGES_DATASET.NAME AS "IMAGE_NAME", HISTOGRAM_EUCLIDEAN_DISTANCE(IMAGES_DATASET.COLOR_HISTOGRAM_VECTOR, IMAGE_COLOR_HISTOGRAM_VECTOR) AS "IMAGE_DISTANCE"
		FROM IMAGES_DATASET, IMAGES
		WHERE IMAGES.NODE_ID = ANY(PARENT_IDS)
		AND IMAGES_DATASET.ID = IMAGES.IMAGE_ID
		AND	HISTOGRAM_EUCLIDEAN_DISTANCE(IMAGES_DATASET.COLOR_HISTOGRAM_VECTOR, IMAGE_COLOR_HISTOGRAM_VECTOR) <= RADIUS
		ORDER BY HISTOGRAM_EUCLIDEAN_DISTANCE(IMAGES_DATASET.COLOR_HISTOGRAM_VECTOR, IMAGE_COLOR_HISTOGRAM_VECTOR) 
		ASC
		LIMIT 10;
END;
$$ 
LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION DELETE_IMAGE() 
RETURNS TRIGGER AS $body$
DECLARE
	NODES_AT_SAME_LEVEL int;
	CURRENT_NODE_CHILDREN_COUNT int;
	PARENT_NODE_ID int;
	NEXT_PARENT_NODE_ID int;
BEGIN
	CURRENT_NODE_CHILDREN_COUNT = (
		SELECT COUNT(*)
		FROM NODES
		WHERE PARENT_ID = OLD.NODE_ID
	);

	IF (CURRENT_NODE_CHILDREN_COUNT = 0) THEN

	PARENT_NODE_ID := (
		SELECT PARENT_ID
		FROM NODES
		WHERE NODE_ID = OLD.NODE_ID
		LIMIT 1
	);

	DELETE FROM NODES WHERE (NODE_ID = OLD.NODE_ID);

	NODES_AT_SAME_LEVEL := (
		SELECT COUNT(*)
		FROM NODES
		WHERE PARENT_ID = PARENT_NODE_ID
	);

	WHILE NODES_AT_SAME_LEVEL = 0 LOOP
		NEXT_PARENT_NODE_ID := (
			SELECT PARENT_ID
			FROM NODES
			WHERE NODE_ID = PARENT_NODE_ID
			LIMIT 1
		);

		IF (NEXT_PARENT_NODE_ID IS NOT NULL) THEN

		DELETE FROM NODES WHERE (NODE_ID = PARENT_NODE_ID);
		PARENT_NODE_ID := NEXT_PARENT_NODE_ID;
		END IF;

		NODES_AT_SAME_LEVEL := (
			SELECT COUNT(*)
			FROM NODES
			WHERE PARENT_ID = PARENT_NODE_ID
		);

	END LOOP;
	ELSE
		RETURN NULL;
	END IF;

	RETURN OLD;
END
$body$ LANGUAGE PLPGSQL;


CREATE TRIGGER DELETE_IMAGE AFTER
DELETE ON IMAGES
FOR EACH ROW EXECUTE PROCEDURE DELETE_IMAGE();


CREATE OR REPLACE FUNCTION EDIT_IMAGE() RETURNS TRIGGER AS $body$
BEGIN
	DELETE FROM IMAGES WHERE (IMAGE = OLD.IMAGE);
	INSERT INTO IMAGES(IMAGE) values (NEW.IMAGE);

	RETURN NEW;
END
$body$ LANGUAGE 'PLPGSQL';

CREATE TRIGGER EDIT_IMAGE AFTER
UPDATE ON IMAGES
FOR EACH ROW EXECUTE PROCEDURE EDIT_IMAGE();